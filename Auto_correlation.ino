const int samples=125;
float x[samples]={-133.8337942,-260.4974533,-241.6614439,-274.0937565,-260.4267271,-275.0870365,-241.6572236,-129.0496015,-18.44603851,-5.898622824,-37.92671759,-114.288928,-130.0876598,-194.3384195,-203.7566508,-197.6452964,-178.4015046,-195.5265031,-203.0038316,-187.6826071,-220.1076111,-222.0867574,-229.8035474,-228.2096952,-238.4556715,-261.6103092,-256.1882952,-273.8256267,-246.7806799,-149.8920876,-41.97354037,13.52678239,-24.46978701,-73.18262783,-113.8766569,-139.2187799,-187.7474312,-199.2423444,-205.8824028,-171.7711651,-183.4533394,-188.8763012,-168.3754778,-197.2131244,-213.7849009,-246.139012,-240.2017992,-246.5017584,-270.2900898,-265.1524248,-253.1700631,-164.51192,-52.48547631,38.15558943,13.31182846,-73.0663413,-119.3044299,-148.0791929,-167.1488984,-189.8425119,-192.3906048,-193.6765921,-183.7224265,-174.8775811,-171.2027543,-197.6146666,-232.4531978,-228.237979,-246.0410993,-255.8837126,-261.5904097,-273.958888,-268.3196054,-237.7107159,-123.7114857,0.226391954,22.66864417,-38.04342286,-98.35051706,-139.1754034,-165.7568608,-178.787621,-194.1632423,-199.4276803,-181.0074172,-185.9685907,-206.6435847,-223.1503475,-229.9623259,-228.3718488,-246.2796045,-258.1644405,-256.9879936,-270.3016726,-274.0029898,-258.5661217,-212.815258,-77.54159481,9.102854345,12.1129301,-56.67444497,-111.4469518,-151.1588564,-200.0708773,-203.3514343,-198.2118784,-206.3766966,-184.8812806,-175.8059768,-178.3083993,-192.0818142,-240.4398982,-236.1946918,-232.950626,-248.5757493,-260.162736,-261.3312421,-257.4183373,-258.4199319,-194.9189394,-63.58234451,16.24253298,-8.243009123,-67.52077091,-141.475889
};

float max_value;
int FNZCP;
float y[samples];
float rxx[samples];

float sumv2;
float sumv, meanv;

void setup() {
  // put your setup code here, to run once:

  Serial.begin(9600);  //baud rate

}

void loop() {
  // put your main code here, to run repeatedly:
 // y=x/max(abs(x))

 max_value=-100000;
 for(int i=0; i<samples; i++)
 {

    max_value=max(max_value, abs(x[i]));
  
 }

 for(int i=0; i<samples;i++)
 {
    y[i]=x[i]/max_value;
  
 }

sumv=0;
 for(int i=0; i<samples; i++)
 {
   sumv=sumv+y[i];
 }

 meanv=sumv/samples;

for(int i=0; i<samples; i++)
{
  y[i]=y[i]-meanv;
}

// Auto Correlation Function
for(int L=0; L<(samples); L++)
{   
    sumv2=0;
    for(int i=0; i<(samples-L-1);i++)
    {
        sumv2=sumv2+y[i]*y[i+L];
    }
    rxx[L]=sumv2;

}
//first negative zero corossing
{
  for(int i=1;i<samples;i++)
  {
    if(rxx[i-1]>0 && rxx[i+1]<0)
    {
      FNZCP=i;
      break;
    }
  }
  Serial.println(FNZCP);
}

}

 
